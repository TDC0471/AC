━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━

Any notes or extended source snippets that would bloat the actual source files.
Maybe change this to a Markdown file, if it becomes unwieldly otherwise.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━

= IdentIcon =
flowtron started implementing an IdentIcon rendering for the pubkey (actually: pubkeyhex). 
Since the original 9block algorithm – see: https://en.wikipedia.org/wiki/Identicon – 
has a tendency to look like a swastika it was felt to be better to go more in the direction of the github avatar icons.
Several implementations in the direction of this propietary solution exist as OpenSource, they usually deal with 32bytes.
Since the pubkeyhex is always 64 bytes (only hexadecimal subset), our implementation needs to be different.
Folding down too much of the key into the central pattern is not desirable, but having unused characters even more so.
The implementation is trying to keep the visual cue as sharp as possible w/o too much chances of collision. 
A number of decisions may be revisited; as long as any change of visualisation triggers a minor version bump (A.B.C => A.(B+1).0).
The underlying pubkey is, of course, the relevant information but humans will likely be showing the image, they need to use matching algorithms.

Technical issues:
 - after experiences (beta?) have been gathered some ordering and restraints may want to be implemented
   Like: limit the size of the folder, currently 10K icons take up 41 MB, so not critical.
   Marking people as friends and clanmates should make them exempt from cleaning, possibly observe "last seen"(TODO) for others.
 - The blockiness of the image should suit JPEG, but in tests at 50% quality the PNG was still 6× smaller. GIF could improve on it, but needs implementing. 

Algorithm description:
IdentIcon For 64 byte AC:pubkey hex representation:
 - we use bytes 0…44 for the inner pattern.
   three bytes inform each of the cells, three cells for each of the five rows (ABCBA).
 - byte 45 is currently unused 
 - border & blocks RGB from byte pairs 46–57
 - corners from 58+59+60 (hueblock)
 - edges from 61+62+63 (hueblock)
To create our icon we have two parts working differently; one way to create a github style IdentIcon as central pattern and
another to pad the pattern so all the bytes are used but the visual simplicity still allows for quick recognition *and* rejection.
For the padding area we use the padhues array of clearly different shades of gray. 
Adding colours to corners and edges is possible but visual accessibility should be considered.
There are 2 shades used, one for the corners and one for the edges between them.
The establishing of which hue to use is based on the sum of three bytes. The middle hue is least likely.
The whole image gets a border whose colour is decided on as RGB channel values of 6 bytes (so:0x000000 – 0xFFFFFF); the blocks in the pattern too.
This pattern is backdropped in white and the block colour is forced to have a minimal distance from white, for contrast.
The pattern itself is established row by row, each row has three cell values, so groups of three bytes inform a 5 cell row.
The first cell matches the last and the second the fourth (like ABCBA). Each cell is ON if the byte is odd, OFF if even.
This may lead to quite a few collisions; but attempts to mitigate this have not rendered as pleasingly.

Relic of the time JPEG was tried:
// jpegenc jpegencoder; jpegencoder.encode(imagepath, image, 50, uhash); // IDEA: have player name in jpeg comment instead of uhash 

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━

= VITA =
The concept of a players vita was introduced during the long dark tea time of the game; 
all of the intended and/or required mechanisms have not been realized or implemented - our mileage *will* vary.
What the best outcomes of using this new feature can be will definitely include:
  A) establishing properly reliable ranking data
     A.1) for assembling well balanced teams on the fly
     A.2) for leaderboards
  B) making cheating a much more socially costly act

If we can establish a way to send vita data upstream to the MS, combine it and send it back downstream then all servers
will be aware of the current ranking across the network of any player that connects – which already highlights one issue when
attempting to implement this: the entire database is going to have a tendency to explode in size, some form of "chunks" need
to be separated but there shouldn't need to be a back-n-forth between every server and the MS whenever someone joins.
Also, of course, the question of reliability of server provided data must be addressed; a naive approach would keep the 
backlog of each server submission for a *long* time so that once a bad apple turns up those submissions can be discarded and
a new value calculated based on the remaining data.

As a temporary solution there could be a group of clan server admins that trust each other and share their local files with
a person that has some python script or other small program capable of merging the data. It would need to be a little more 
than plain "add & divide by N" (for N servers) though, since otherwise the amount of one-time-identities will explode the size.
So keeping track of when last any given PUBKEY was seen would be a requirement even for this simple tool.

This way your vita will become an important social aspect of the game, even allowing for things like servers filtering players. 
For example: "need to have played X hours before joining", "need a skill value above X to join" or combinations … or …
So losing your established vita because your PUBKEY was banned for cheating could become painful.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━ ━━━━━━━

